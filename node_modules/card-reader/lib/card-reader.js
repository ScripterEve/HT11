"use strict";

var _events = require("events");

var _pcsclite = _interopRequireDefault(require("pcsclite"));

var _hexify = _interopRequireDefault(require("hexify"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var events = new _events.EventEmitter();
var pcsc = (0, _pcsclite["default"])();
var devices = {};

events.listDevices = function () {
  return Object.keys(devices);
};

events.fetchDevice = function () {
  return Object.keys(devices);
};

var cardInserted = function cardInserted(reader, status) {
  reader.connect(function (err, protocol) {
    if (err) {
      events.emit('error', err);
    } else {
      devices[reader.name] = {
        reader: reader,
        protocol: protocol
      };
      events.emit('debug', "Device '".concat(reader.name, "' has protocol '").concat(protocol, "'"));
      events.emit('card-inserted', {
        reader: reader,
        status: status,
        protocol: protocol
      });
    }
  });
};

var cardRemoved = function cardRemoved(reader) {
  reader.disconnect(reader.SCARD_LEAVE_CARD, function (err) {
    if (err) {
      events.emit('error', err);
    } else {
      devices[reader.name] = {};
      events.emit('card-removed', {
        reader: reader
      });
    }
  });
};

var isCardInserted = function isCardInserted(changes, reader, status) {
  return changes & reader.SCARD_STATE_PRESENT && status.state & reader.SCARD_STATE_PRESENT;
};

var isCardRemoved = function isCardRemoved(changes, reader, status) {
  return changes & reader.SCARD_STATE_EMPTY && status.state & reader.SCARD_STATE_EMPTY;
};

var deviceActivated = function deviceActivated(reader) {
  devices[reader.name] = {};
  events.emit('device-activated', {
    reader: reader
  });
  reader.on('status', function (status) {
    var changes = reader.state ^ status.state;

    if (changes) {
      if (isCardRemoved(changes, reader, status)) {
        cardRemoved(reader);
      } else if (isCardInserted(changes, reader, status)) {
        cardInserted(reader, status);
      }
    }
  });
  reader.on('end', function () {
    delete devices[reader.name];
    events.emit('device-deactivated', {
      reader: reader
    });
  });
  reader.on('error', function (error) {
    events.emit('error', {
      reader: reader,
      error: error
    });
  });
};

pcsc.on('reader', function (reader) {
  deviceActivated(reader);
});
pcsc.on('error', function (err) {
  events.emit('error', {
    error: error
  });
});

events.issueCommand = function (reader, command, callback) {
  var commandBuffer;

  if (Array.isArray(command)) {
    commandBuffer = new Buffer(command);
  } else if (typeof command === 'string') {
    commandBuffer = new Buffer(_hexify["default"].toByteArray(command));
  } else if (Buffer.isBuffer(command)) {
    commandBuffer = command;
  } else {
    throw 'Unable to recognise command type (' + _typeof(command) + ')';
  }

  var protocol = devices[reader.name].protocol;
  events.emit('command-issued', {
    reader: reader,
    command: commandBuffer
  });

  if (callback) {
    reader.transmit(commandBuffer, 0xFF, protocol, function (err, response) {
      events.emit('response-received', {
        reader: reader,
        command: commandBuffer,
        response: new Buffer(response.toString('hex'))
      });
      callback(err, response);
    });
  } else {
    return new Promise(function (resolve, reject) {
      reader.transmit(commandBuffer, 0xFF, protocol, function (err, response) {
        if (err) reject(err);else {
          events.emit('response-received', {
            reader: reader,
            command: commandBuffer,
            response: new Buffer(response.toString('hex'))
          });
          resolve(response);
        }
      });
    });
  }
};

module.exports = events;